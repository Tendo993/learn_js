//                #2

// Типы данных, операторы, методы и свойства

// Примитивные типы данных
let num = 10, // число, к числам также относятся Infinity и NaN
  string = 'Hello world', // строка
  bool = true, // логический, булеевый
  n = null, // null - специальный тип
  u = undefined, // не заданное значение
  s = Symbol(); // символ

// Строки можно заключать в кавычки тримя способами:
let name = 'Ilia',
  s1 = 'hello', // одинарные кавычки
  s2 = "my", // двойные кавычки
  s3 = `friend, ${name}`; // Обратные кавычки, позволяют вставлять в строку значение переменной, имя переменной заключается в ${ }.

console.log(s1 + ' ' + s2 + ' ' + s3);

// Объект и объектные типы данных
let obj = {}, // Объект
  arr = [], // Массив
  regExp = /w+/g, // Регулярное выражение
  func = function () {}; // функция
error = Error('error message'), // ошибки
  data = new Date(); // Дата

// Всего в javascript 7 типов данных.

console.log(typeof (n)); // Вывести в консоль тип данных переменной n.

//  || - логическое "или"
//№  ! - логическое "не"
//  && - логическое "и"


//  Логическое " И "
let a = x && y; // Присвоит переменной a значение x если значение x может быть конвертировано в false, в противном случае a будет присвоино значение y. Таким образом при использовании булеевых значений логическое && возвращает true только когда оба операнда равны true, в противном случае возвращает false.
let a1 = true && true, // true && true вернет true
  a2 = true && false, // true && false вернет false
  a3 = false && true, // false && true вернет false
  a4 = false && (3 == 4), // false && false вернет false
  a5 = 'cat' && 'dog', // true && true вернет dog
  a6 = false && 'cat', // false && true вернет false
  a7 = 'cat' && false; // true && false вернет false

// Логическое " ИЛИ "
let a = x || y; // Присвоит переменной a значение x если оно может быть конвертировано в true, в противном случае a будет присвоино значение y. Таким образом при использовании булеевых значений логическое || если любой из операндов равен true, если оба операнда равны false - присвоит false.
let o1 = true || true, // true || true вернет true
  o2 = true || false, // true || false вернет true
  o3 = false || true, // false || true вернет true
  o4 = false || (3 == 4), // false || false вернет false
  o5 = 'cat' || 'dog', // true || true вернет cat
  o6 = false || 'cat', // false || true вернет cat
  o7 = 'cat' || false; // cat || false вернет cat

// Орифметические операции

// " +3 " - унарный плюс в оснавном используется для преобразования значения переменной в число
// " -3 " - унарный минус используется для преобразования к отрицательному значения
// "++i" "i++" "--i" "i--" префиксный и постфиксный инкримент/декримент
// префиксный инкримент/декримент сначала изменяет переменную, а потом ее использует
// постфиксный инкримент/декримент сначала использует переменную а потом ее изменяет

// " > " - больше
// " < " - меньше
// " >= " - больше или равно
// " <= " - меньше или равно
// " === " - строгое соответствие, проверка на равенство без приведения типов
// " !== " - строгое несоответствие
// " == " - нестрогая проверка на равенство
// " != " - 
// На практике лучше использовать строгую проверку на равенство

// Алгоритм сравнения строк:
// 1) Сначала сравниваются первые символы строк.
// 2) Если первый символ первой строки больше(меньше), чем первый символ второй, то первая строка больше(меньше) второй.
// 3) Если первые символы равны, то таким же образом сровниваются уже вторые символы строк.
// 4) Сравнение продолжается, пока не закончится одна из строк.
// 5) Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.
// Сравнение символов происходит согласно их номеру в таблице юникода




let x = 5;

Math.sqrt(x); // метод извлечения корня
Math.pow(x, 3); // Метод возведения x в 3-ю степень, "x ** 3" - новая форма записи возведения в степень
Number.isInteger(x); // Вернет true если число целое и false если число дробное

let str = 'Hello world';

str.length; // Вернет длинну строки
str.toUpperCase(); // Вернет строку в которой все символы будут в верхнем регистре
str.toLowerCase(); // Вернет строку в которой все символы будут в нижнем регистре
str.charAt(5); // Вернет символ который строит в строке под номером 5, важно учитывать что счет начинается с 0!
str[5]; //  аналог str.charAt[5]
str.substring(5, 15); // Вернет строку начиная с символа с индексом 5 и и заканчивая символом с индексом 14, если второй парамерт не указан - строка будет выведена с 5-го символа и до конца строки
str.slice(5); // вернет строку начиная с символа с индексом 5
str.slice(-8); // Вернет строку состоящую из 8-ми последних символов строки
str.substr(5, 9); // Вернет 9 символов начиная с символа с индексом 5
str.indexOf('world'); // Вернет индекс первого символа из найденой подстроки, если буквы/символа/слова в строке нет - метод вернет "-1"
str.replace('world', 'friends'); // Заменит слово world на friends
str.split(' '); // Нарезка строки на массив, в кавычках указывается раздеритель который будет указывать на отдельные элементы массива, в данном случае пробел
// Все эти методы работы со строками не изменяют исходную строку, а возвращают новую строку


//      ===     ===     ===      ===     ===     ===      ===     ===     ===      ===     ===     ===      ===     ===     ===      ===     ===     ===


//                #3

// Взаимодействие с пользователем, динамическая типизация и ветвление в JavaScript

let question = confirm('Ты человек?'); // Выводит модальное окно с сообщение и кнопками "Ок" и "Отмена", возвращает true или false в зависимоти от того какая кнопка была нажата.
let question2 = prompt('Как тебя зовут?', 'Илья'); // Выводит модальное окно с сообщением, значение поумолчанию, текстовым полем и кнопками "ок" и "отмена". Возвращает строку с текством от пользователя или null в случае если нажали кнопку "отмена".

// Преобразование типов

// number + string = string
// number - string = number
// numer * string = number
// number / string = number
// Если строка в результате вычитания, умножения, деления не может быть вычислена вернет NaN:
// 'JS' / '5' = NAN

// Преобразование в булеевый тип
console.log(Boolean(5)); // true
// или
console.log(!5); // false
console.log(!!5); // true

// Преобразования которые возвращают false:
Boolean(''); // false
Boolean(0); // false
Boolean(-0); // false
Boolean(NaN); // false
Boolean(null); // false
Boolean(undefined); // false
Boolean(false); // false

// Любые значения, не входящие в этот список преобразуются в true, включая объекты, функции, массивы, даты, а также типа, определенные пользователем. Значения типа Symbol также преобразуются в true. пустые объекты и пустые массивы тоже преобразуются в true.

Boolean({}); // true
Boolean([]); // true
Boolean(Symbol()); // true
!!Symbol(); // true
Boolean(function () {}); // true

// Преобразования к типу String
String([1, 2, 3]); // Строка '[1,2,3]'
let x = 10 + ''; //  Строка '10'
// метод .toString() работает только с числами и булиновыми значениями
x = 10..toString(); // Строка '10'
// Преобразование символов в строку возможно только через функцию String
String(Symbol('my symbol')); //  строка 'Symbol('my symbol')'
console.log('this is ' + true); // 'this is true'

// Преобразование в число
// Через функцию Number
x = Number('10'); //  Число 10
// Через унарный оператор ' + '
x = +'10'; // Число 10
// Использование унарного оператора в prompt
let question = +prompt('Сколько тебе лет?'); // Значение будет преобразовываться в числовой тип, если пользователь введет не число - то значение будет NaN.
console.log(parseInt('10', 10)); // Преобразует строку в число без плавающей запятой символ за символом пока не дойдет до конца строки или до символа не являющегося числом, вторым параметром принимает систему счисления. Если перед числовым символом будет любой другой символ - функция вернет NaN.
console.log(parseFloat('10')); // Преабразует строку в число с плавающей запятой.
console.log(Number('6' / '2')); // 3
console.log(Number('string')); // NaN
console.log(Number(undefined)); // NaN
console.log(Number(true)); // 1
console.log(Number(false)); // 0
console.log(Number(null)); // 0

// Ветвление в javaScript

if (true) {
  console.log('true');
} else {
  console.log('false');
}

switch (n) {
  case 1: // case проверяет на строгое соответвие и если n = '1' - условие не сработает!
    console.log('1');
    break;
  case 2:
    console.log('2');
    break;
  case 3:
  case 4:
  case 5:
    console.log('группировка кейсов 3,4,5 когда для разных вариантов используется одна обработка');
    break;
  default:
    console.log('default');
}

// Тернарный оператор
x ? y : z; //  Если x = true - выполнится y, если x = false - выполнится z;
x === 5 ? console.log('x = 5') : console.log('x != 5');
// Несколько тернарных операторов
x === 5 ? console.log('x = 5') : x === 7 ? console.log('x = 7') : console.log('x != 5 && x != 7')


//      ===     ===     ===      ===     ===     ===      ===     ===     ===      ===     ===     ===      ===     ===     ===      ===     ===     ===


//                #4

//  


















//      ===     ===     ===      ===     ===     ===      ===     ===     ===      ===     ===     ===      ===     ===     ===      ===     ===     ===


//                 #17 

// Работа с JSON, AJAX, Получение и отправка данных на сервер

// AJAX позволяет менять содержимое страницы без ее перезагрузки.
// JSON - javascript object notation, текстовый формат данных, набок ключей и значений.
// JSON используется для отправки данных на сервер.

// Пример использование JSON с объектом:

const smartphone = {
  brand: 'samsung',
  screen: 5.5,
  rom: 128,
  ram: 4,
  gps: true,
  sensor: ['Accelerometer', 'E-compass', 'Fingerprint Sensor', 'Gyroscope'],
  camera: {
    back: [32, 5, 8],
    front: 16
  }
};

// В JS есть объект для работы с JSON, называется JSON. У него есть два метода: parse() и stringify().

// Выведем в консоле объект JSON:
console.log(JSON);

// Метод stringify() переводит объект в формат JSON:
const jsonSmart = JSON.stringify(smartphone);

console.log(jsonSmart);
// В файле JSON не может содержаться одинарных кавычек, все ключи и их значения записываются в двойных кавычках(автоматически преобразовует одинарные кавычки в двойные). На выходе метода JSON.stringify(smartphone) мы получим:
// {"brand":"samsung","screen":5.5,"rom":128,"ram":4,"gps":true,"sensors":["Accelerometer","E-compass","Fingerprint Sensor","Gyroscope"],"camera":{"back":[32,5,8],"front":16}} Все одной строкой.

// Метод parse() переводит переменную формата JSON в объект:

Console.log(JSON.parse(jsonSmart));

// Работа с JSON и AJAX

document.addEventListener('DOMContentLoaded', () => {
  'use strict';

  const select = document.getElementById('cars'),
    output = document.getElementById('output');

  const request = new XMLHttpRequest(); /* Создаем экземпляр XML запроса */

  // У объекта XMLHttpRequest есть метод open() который используется для инициализации запроса, его синтаксис: open('метод получение/отправки данных', 'путь к сервере/файлу', true/false(asinc - установить многопоточную обработку или ждать отклика от сервера, по умолчанию -  true), login, password) последние три параметра не обязательные.

  request.open('GET', './cars.json');

  // Метод setRequestHeader() - устанавливает заголовок запроса

  request.setRequestHeader('Content-type', 'application/json');

  // Метод send() открывает соедининение и отправляет запрос:

  request.send();

  // События XMLHttpRequest: loadstart, progress, abort, timeout, load, error, loadend, readystatechange

  /* Необходимо запускать до передачи заголовка и тела запроса

    request.addEventListenet('loadstart', (event) => {
      console.log(event);
    })

  */
  // progress срабатывает во время получения данных от сервера
  // abort срабатывает про использование метода abort() во время выполнения запроса
  // load срабатывает при успешном завершении запроса
  // error срабатывает когда запрос завершился ошибкой
  // loadend срабатывает при завершении засобития через load, error или abort.(не кроссбраузерный)
  // readystatechange срабатывает несколько раз за запрос, имеет 5 состояний:
  /* 0 - при создании запроса до вызова open(),
     1 - при вызове open(),
     2 - при вызове sent() и полученны заголовки,
     3 - при загрузке тела и свойство responseText может созадержать часть данных
     4 - при завершении передачи данных от сервера. */
  request.addEventListener('readystatechange', (event) => {
    if (request.readyState === 4 && request.status === 200) {
      // request.status содержит числовое значение код состояния http ответа сервера, пока статус не равен 200 нам ничего делать не нужно.
      // request.statusText - текстовоя содержание состояния сервера.
      const data = JSON.parse(request.responseText);
      data.cars.forEach(item => {
        /* перебормассива данных */
        if (item.brand === select.value) {
          const {
            brand,
            model,
            price
          } = item; /* деструктуризация */
          output.innerHTML = `Тачка ${brand} ${model} <br>
          Цена: ${price}$`
        }
      });
      // request.response - тело ответа от сервера(передаваемые данные) 
      // request.responseText - текст передаваемый запросом от сервера
    } else {
      output.innerHTML = 'Произошла ошибка';
    }
  });
});

// Важно!!!
// У инпута обязательно должен быть атрибут name, если его не будет - то при отправке у данных не будет ключа и отправка не сработает!

// Как отправлять данные ввиде formData или же ввиде json зависит от того какой тип данных понимает сервер. Тип передаваемых данных указывается в шапке запроса.



//               #18
//Контекст выполнения, асинхронное выполнение, стек вызовов и event loop

// Ключевое слово dubugger; - это метка на которой приостановится выполнение кода
// Программа приостановится только если открыта консоль.
// В Call Stack функция попадае в момент её вызова и убирается при завершении выполнения.
// Функции добавляются в Call Stack сверху вниз и убираются тоже сверху вниз.
// На пример если одна функция вызывает другую то в стек сначала добавится первая функция, потом вызванная ею функция, после того как вторая функция отработает она будет удаленна из стека и продолжится выполнения первой функции, после того как первая функция завершится - она тоже будет удалена из стека.
// Если при выполнении функции вызванной другой функцией возникнет ошибка - в консоль будет выведен весь Call Stack.
// Call Stack можно переполнить если вызвать функцию 16000 раз.
// Это можно сделать через самовызывающуюся функцию.
// Если Call Stack будет переполнен в консоли будет выведено сообщение о переполнении и последний стек вызова.

// При работе с setTimeout расчет времени производится не в js, а в web api.

//          Promise

// Промисы - callback function 
const promise = new Promise();
// Можно не используя переменную создать promise, в таком случае return после промиса писать не нужно.
// return new Promis(() => {});
// Функция new Promise() в качестве параметра принимает executive function(функция-исполнитель) которая будет выполнять определенные действия:
const doUniversity = (docs) => {
  return new Promise((resolve, reject) => {
    if (docs) {
      console.log('Рассмотрение документов...');
      setTimeout(() => {
        if (Math.random() > 0.3) {
          let result = 'Принят';
          resolve(result); // выполнится первая функция .then((1), (2)), если будет указанно несколько resolve подряд, то выполнится только первый.
        } else {
          reject('Отказано'); // выполнится вторая функция .then((1), (2)), если будет указанно несколько reject подряд, то выполнится только первый.
        }
      }, 3000);
    } else {
      reject('Отказано, не хватает документов');
    }
  });
};
const doArmy = (docs) => {
  return new Promise((resolve, reject) => {
    if (docs) {
      console.log('Военкомат думает...');
      setTimeout(() => {
        if (docs === 'Принят') {
          resolve('Отсрочка');
          console.log('Отсрочка');
        } else {
          reject('Повестка');
        }
      }, 2000);
    } else {
      reject('Повестка');
    }
  });
};
const doWork = (docs) => {
  return new Promice((resolve, reject) => {
    console.log('Директор Google думает...');
    setTimeout(() => {
      if (Math.random() > 0.3) {
        let result = 'Приглашаем на собеседование в Google в понедельник';
        resolve(result);
      } else {
        reject('Отказано иди в Яндекс!');
      }
    }, 3000);
  });
};

const dance = (docs) => {
  console.log('Потанцевали');
  return docs;
  // return Promise.resolve(docs); - Принудительно возвращает положительный результат
  // return Promise.reject(docs); - Принудительно возвращает отрицательный результат
};

// У промисов есть метод .then() который обрабатывает последствия обещания.
const documents = ['Паспорт', 'Аттестат'];
doUniversity(documents)
  .then((result) => {
    console.log(result);
    return result; // передаст результат в следующий .then()
  })
  .then(doArmy)
  .then(dance)
  .then(doWork)
  .catch((reason) => {
    console.error(reason)
  })
  .finnaly(() => console.warn('Выполнится в любом случае'));

// метод .catch() обрабатывает все возвражения в случае если любая из функций doUniversity, doArmy, doWork вернет отрицательный promise.
// пока promis ожидает окончание setTimeout он находится в режиме ожидания(panding), если promis выполнен успешно он перейдет в состояние full filled. Если промис завершится ошибкой(не удачей) он перейдет в состояние reject.
// Последний .then стоящий после .catch выполнится в любом случае(УстарелБ теперь используют .finally)

// Promise.all([]) - метод который будет дожитаться выполонения всех промисов указанных в качестве параметров. В качестве параметров указывается массив промисов.

const doWorking = (company) => {
  return new Promise((resolve, reject) => {
    const time = Math.ceil(Math.random() * 3000);
    setTimeout(() => {
      if (item % 5) {
        resolve(company);
      } else {
        reject(company);
      }
    }, time);
  });
};

const hh = doWorking('HH'),
  yandex = doWorking('Yandex'),
  ozone = doWorking('Ozone'),
  pikabu = doWorking('Pikabu'),
  politics = doWorking('Гос Дума');

Promise.all([hh, yandex, ozone, pikabu, politics])
  .then(result => console.log(`Тебя пригласили на собеседование в: ${result}`))
  .catch(result => console.error(`Компания ${result} отказала`));

// Promise.race - метод который допустит к .then первый отработавший промис
Promise.race([hh, yandex, ozone, pikabu, politics])
  .then(result => console.log(`Тебя пригласили на собеседование в: ${result}`))
  .catch(result => console.error(`Компания ${result} отказала`));



//          19
// Fetch
// Fetch - api для получения данных с сервера.
// Функция fetch является методом объекта window. В качестве первого параметра принимает url-адресс, в качестве второго параметра получает объект с настройками. Функция fetch возвращает промисы которые нужно обрабатывать при помощи .then и .catch. 
// thorw - исключение при работе с .then, Прерывает выполнение .then и отправляет в .catch.
// new Error - конструктор ошибок.
// body у fetch - тело ответа от сервера. Передается ввиде ReadebalStream. 
// Обработка получаеммых через fetch данных: json, block, text.
// Настройки fetch
// 1) Метод передачи данных, по умолчанию GET: method: 'GET
// 2) Mode - режимы правил ограничения доменов, по умолчанию same-origin, cors - для получения данных со стороннего сервера.
// 3) cache - режим кеширования, по умолчанию default
// 4) credentials - указывает можно ли передавать учетные данные вместе с запросом
// 4) headers - объект с заголовками
// 5) redirect - поведение при редиректе: follow -  автоматическая переадресация, mellow - ручная переадресация, error -  ошибка пре переадресации.
// 6) referrer - позволяет указать откуда пришел запрос
// 7) body - тело запроса: JSON.stringify();

// Настройка webpack и babel для работы с js
// установака webpack dev server
// npm install --save-dev webpack-dev-server
// Настройка package.json:
// "scripts": {
//   "dev": "webpack-dev-server --open --mode=development",
//   "build": "webpack mode=production"
// }
// Для настройки webpack нужно в корневой папке проекта создать файл webpack.config.js
// Нужно установить npm i path -D
// Настройка webpack.config.js :
// const path = require('path');
// module.exports = {
//   entry: {
//     main: './src/index.js'
//   }, // Точка входа, можно указать объект с точками входа
//   output: { // Точка выхода
//     path: path.resolve(__dirname, './dist'),
//     filename: '[name].js',// если точка входа одна можно указать bundle.js, если несколько точек входа желательно указывать [name].js
//     publickPath: '/dist'
//   }
// };
// npm run dev - запустить проект в режиме разработки
// В режиме разработки папка dist не будет создана
// Установка balel: npm install -D babel-loader @babel/core @babel/preset-env
// Настройки babel:
// Создать файл .babelrc :
// {
//   "presets": ["@babel/preset-env"]
// }

// Установка полифила forEach
// npm i nodelist-foreach-polyfill
// После его нужно импортировать в index.js
// import 'nodelist-foreach-polyfill';

// Устновка babel-polyfill
// npm install --save @babel/polyfill
// import '@babel/polyfill';

// Установка closest-polyfill
// npm i element-closest
// import elementClosest from 'element-closest'; Импорт полифила
// elementClosest(window);  Вызов

// Установка полифила formData
// npm i formdata-polyfill
// import 'formdata-polyfill';

// Установка Promise polyfill
// npm i es6-promise
// import 'es6-promise';

// Установка Fetch polyfill
// npm i fetch-polyfill
// import 'fetch-polyfill';

// npm run build - сборка проекта на продакшн



//              #23
//          try, catch
// конструкция try catch позволяет перехватывать ошибки
// Код заключенный в try выполняется по умолчанию, а код заключенный в catch будет выполняется только в том случае, если при выполнении кода заключенного в try возникла ошибка.
try {
  console.log('hello');
} catch (error) {
  console.log(error);
}
// При использовании конструкции try catch даже в случае возникновения ошибки код продолжит работать.
// В конструкцию try catch можно добавить блок finally который будет выполняться в любом случае.
try {
  console.log('try');
} catch (error) {
  console.log(error);
  console.log(error.name);
  console.log(error.message);
  console.log(error.stack); /* выводится по умолчанию */
} finally {
  // Блок finally используется очень редко.
}

//          async await
// Объявление function decloration при работе с async
async function funcFirst() {
  return 'hello';
};
// Объявления function expression при работе с async
const fucnTwo = async function () {
  return 'hello';
};
// Объявления arrow function при работе с async
const funcThree = async () => {
  return 'hello';
};
// jshint не поддерживает async
// async функции всегда возвращают Promise которые можно обработать при помощи then
const funcThree = async () => {
  return 'hello';
};
funcThree().then(res => console.log(res) /* Выведет в консоль возврощаемые промисом данные */ ).catch(error => console.warn(error) /* Отработает если async функция вернет ошибку */ );

// await сказывается на выражения, если await функция является промисом - то async функция будет преостановленна до тех пор пока промис не выполнится, если выражение не является промисом - то оно будет конвертироваться в промис.